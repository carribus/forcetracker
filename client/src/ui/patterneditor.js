import { Component } from "./component.js";
import { InputHandler } from "./inputhandler.js";
import { Note } from "../sound/note.js";
import { Track } from "../sound/track.js";

export class PatternEditor extends Component {
    constructor(display, dimensions) {
        super(display, dimensions);
        this.trackWidth = 120;
        this.pattern = null;
        this.lastSampleID = 0;
        this.scrollOffset = {
            x: 0,
            y: 0
        }
        this.fonts = {
            note: {
                name: 'Courier New',
                size: 14,
                weight: 'normal'
            }
        }
        this.colours = {
            defaultFill: 'rgb(16, 16, 16)',
            defaultText: 'rgb(164, 164, 164)',
            playingNoteText: 'white',
            playingNoteFill: 'rgb(32, 32, 32)',
            editNoteText: 'rgb(164, 255, 164)',
            editNoteFill: 'rgb(16, 64, 16)',
            editPositionFill: 'rgb(32, 96, 32)',
            editEmptyNoteText: 'rgb(128, 192, 128)',
            emptyNoteText: 'rgb(128, 128, 128)',
            selectedFill: 'rgb(16, 32, 64)',
            selectedText: 'rgb(128, 296, 255)',
            currentTrackFill: 'rgb(0, 32, 0)',
        }
        this.editPosition = {
            track: 0,
            note: 0,
            position: 0
        }
        this.selection = this._resetSelection();
        this.noteHeight = this.fonts.note.size;
    }

    /**
     * Handles an 'onClick' callback. This can be generated by either mouse click or touch events
     * @param x x co-ordinate of the click
     * @param y y co-ordinate of the click
     */
    onClick(x, y) {
        console.log('Pattern Editor clicked');
        let trackNumber = Math.floor((x - this.rect.x) / this.trackWidth);
        let noteNumber = this.scrollOffset.y + Math.floor((y - this.rect.y) / this.noteHeight);

        console.log('Click: Track %s, Note %s', trackNumber, noteNumber);

        this.editPosition.track = trackNumber;
        this.editPosition.note = noteNumber;
    }

    /**
     * Handled a 'keydown' event
     * @param e KeyboardEvent
     */
    onKeyDown(e) {
        let note;
        let char;
        console.log(`PatternEditor keydown: ${e.keyCode}, shift=${e.shiftKey}`)

        if (e.shiftKey) {
            if (this._isSelectionEmpty()) {
                this._addToSelection();
            }
        } else {
            this.selection = this._resetSelection();
        }

        const ROWS_FOR_PAGEUPDOWN = 16;

        switch (e.keyCode) {
            case    InputHandler.KEYS.VK_PAGEDOWN:
                this.editPosition.note = this.editPosition.note + ROWS_FOR_PAGEUPDOWN >= this.pattern.getNotesPerTrack() ? 
                    this.pattern.getNotesPerTrack()-1 : 
                    this.editPosition.note + ROWS_FOR_PAGEUPDOWN;
                this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
                break;

            case    InputHandler.KEYS.VK_PAGEUP:
                this.editPosition.note = this.editPosition.note - ROWS_FOR_PAGEUPDOWN >= 0 ? 
                    this.editPosition.note - ROWS_FOR_PAGEUPDOWN : 
                    0;
                this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
                break;

            case    InputHandler.KEYS.VK_LEFT:
                this._navigateLeft(e.shiftKey);
                if (e.shiftKey) {
                    this._addToSelection();
                }
                break;

            case    InputHandler.KEYS.VK_RIGHT:
                this._navigateRight(e.shiftKey);
                if (e.shiftKey) {
                    this._addToSelection();
                }
                break;

            case    InputHandler.KEYS.VK_UP:
                this._navigateUp(e.shiftKey);
                if (e.shiftKey) {
                    this._addToSelection();
                }
                break;

            case    InputHandler.KEYS.VK_DOWN:
                this._navigateDown(e.shiftKey);
                if (e.shiftKey) {
                    this._addToSelection();
                }
                break;

            case    InputHandler.KEYS.VK_DELETE:
            case    InputHandler.KEYS.VK_MINUS:
                this.pattern.deleteNote(this.editPosition.track, this.editPosition.note, e.getModifierState('Control'));
                break;

            case    InputHandler.KEYS.VK_PLUS:
                this.pattern.insertNote(this.editPosition.track, this.editPosition.note);
                break;

            case    InputHandler.KEYS.VK_COMMA:
                this._transpose(-1);
                break;

            case    InputHandler.KEYS.VK_PERIOD:
                this._transpose(1)
                break;

            default:
                if (!e.ctrlKey) {
                    switch ( this.editPosition.position ) {
                        // note and octave
                        case    0:
                        case    1:
                        case    2:
                            char = String.fromCharCode(e.keyCode);
    
                            if ( InputHandler.isNoteKey(e.keyCode) ) {
                                note = this.pattern.getNote(this.editPosition.track, this.editPosition.note);
                                if ( !note ) {
                                    note = new Note(char, e.getModifierState('Shift'), 4, this.lastSampleID);
                                } else {
                                    note.noteName = char;
                                    note.isSharp = e.getModifierState('Shift');
                                }
    
                                this.pattern.setNote(this.editPosition.track, this.editPosition.note, note);
                            } else if ( "0123456789".indexOf(char) != -1 ) {
                                note = this.pattern.getNote(this.editPosition.track, this.editPosition.note);
                                if ( note ) {
                                    note.octave = parseInt(char);
                                }
                            } else {
                                note = this.pattern.getNote(this.editPosition.track, this.editPosition.note);
                                if ( note ) {
                                    switch (e.keyCode ) {
                                        case    107:
                                        case    187:
                                            note.increment(1);
                                            break;
    
                                        case    109:
                                        case    189:
                                            note.increment(-1);
                                            break;
                                    }
                                }
                            }
                            break;
    
                        // volume
                        case    4:
                        case    5:
                            let volume;
                            
                            char = String.fromCharCode(e.keyCode);
    
                            if ( "0123456789ABCDEF".indexOf(char) != -1 ) {
                                note = this.pattern.getNote(this.editPosition.track, this.editPosition.note);
                                if ( !note ) {
                                    note = new Note(null, false, null, null);
                                    this.pattern.setNote(this.editPosition.track, this.editPosition.note, note);
                                }
    
                                if ( note ) {
                                    if ( this.editPosition.position == 4 ) {
                                        volume = parseInt(char + '0', 16) | note.volume & 0x0F;
                                        this.editPosition.position++;
                                    } else if ( this.editPosition.position == 5 ) {
                                        volume = parseInt(char, 16) | note.volume & 0xF0;
                                    }
                                    note.volume = volume;
                                }
                            }
                            break;
    
                        // sample
                        case    7:
                        case    8:
                            char = String.fromCharCode(e.keyCode);
                            let sample;
    
                            if ( '0123456789'.indexOf(char) != -1 ) {
                                note = this.pattern.getNote(this.editPosition.track, this.editPosition.note);
                                if ( note ) {
                                    if ( this.editPosition.position == 7 ) {
                                        sample = parseInt(char + '0', 16) | note.sampleID & 0x0F;
                                    } else if ( this.editPosition.position == 8 ) {
                                        sample = parseInt(char, 16) | note.sampleID & 0xF0;
                                        this.editPosition.position++;
                                    }
                                    this.lastSampleID = note.sampleID = sample;
                                    this.editPosition.position++;
                                }
                            }
                            break;
                    }
                    break;
                } else {
                    switch (e.keyCode) {
                        case 65: // A
                            if (e.ctrlKey) {
                                // select the current track
                                this.selection = this._resetSelection();
                                this.selection.startTrack = this.selection.endTrack = this.editPosition.track;
                                this.selection.startNote = 0;
                                this.selection.endNote = this.pattern.getTrack(this.editPosition.track).maxNotes - 1;
                            }
                            break;

                        case 68: // D
                            if (e.ctrlKey) {
                                // duplicate the current track
                                if (this.pattern) {
                                    let track = new Track();
                                    track.deserialise(this.pattern.tracks[this.editPosition.track]);
                                    this.pattern.tracks.push(track);
                                }
                            }

                        default:
                            break;
                    }
                }
        }
    }

    onKeyUp(e) {
        if (e.key === "Shift") {
            // this.selection = this._resetSelection();
        }
    }

    /**
     * Mouse wheel event handler
     * @param xOffset
     * @param yOffset
     */
    scroll(xOffset, yOffset) {
        let visibleNotes = Math.floor((this.rect.h / this.fonts.note.size)-1);

        this.scrollOffset.x += xOffset;
        if ( this.scrollOffset.x < 0 ) {
            this.scrollOffset.x = 0;
        }

        this.scrollOffset.y += yOffset;
        if ( this.scrollOffset.y + visibleNotes > this.pattern.getNotesPerTrack() ) {
            this.scrollOffset.y = this.pattern.getNotesPerTrack() - visibleNotes;
        }
        if ( this.scrollOffset.y < 0 ) {
            this.scrollOffset.y = 0;
        }
    }

    render(pattern, currentNote, isPlaying) {
        let rect, ctx;

        this.pattern = pattern;

        if ( this.display ) {
            ctx = this.display.context;
            this.rect = rect = this.calcRect();

            ctx.save();

            this._drawPattern(ctx, rect, pattern, currentNote, isPlaying);

            ctx.restore();

        }
    }

    _drawPattern(ctx, rect, pattern, currentNote, isPlaying) {
        let track, note, noteStr;
        let visibleNotes = Math.floor((rect.h / this.fonts.note.size)-1);
        let editedNote, selectedNote;
        const isNoteSelected = (track, note) => {
            return (
                track >= this.selection.startTrack && track <= this.selection.endTrack &&
                note >= this.selection.startNote && note <= this.selection.endNote
            );
        }

        isPlaying = isPlaying || false;

        ctx.strokeStyle = 'rgb(128, 128, 128)';
        ctx.lineWidth = 0.5;
        ctx.fillStyle = 'rgb(16, 16, 16)';
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);

        // draw the tracks
        if ( pattern ) {
            let i;
            let len = pattern.getTrackCount();

            ctx.strokeStyle = 'rgb(128, 128, 128)';
            ctx.fillStyle = 'rgb(255, 255, 255)';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.lineWidth = 7;
            ctx.font = this.fonts.note.size + 'px' + ' ' + this.fonts.note.name + ' ';
            ctx.beginPath();
            for ( i = 0; i < len; i++ ) {
                track = pattern.getTrack(i);
                ctx.moveTo(rect.x + i * this.trackWidth, rect.y);
                ctx.lineTo(rect.x + i * this.trackWidth, rect.y + rect.h);

                // draw the notes
                let startNote;
                let offset = 0;

                if ( isPlaying ) {
                    startNote = currentNote;
                } else {
                    startNote = this.scrollOffset.y;
                    if ( startNote + visibleNotes > pattern.getNotesPerTrack() ) {
                        startNote = pattern.getNotesPerTrack() - visibleNotes;
                    }
                }

                if ( isPlaying ) {
                    this._ensureNoteIsVisible(0, currentNote);
                }
                for ( let j = 0, maxNotes = pattern.getNotesPerTrack(); j < maxNotes; j++ ) {
                    // the note
                    //  NOTE:OCTAVE
                    //  VOLUME[00-FF]
                    //  SAMPLE ID[00-FF]
                    //  EFFECT
                    selectedNote = isNoteSelected(i, j);
                    editedNote = ( i == this.editPosition.track && j == this.editPosition.note );

                    if ( j < this.scrollOffset.y ) continue;

                    offset = j - this.scrollOffset.y;

                    // fill the line's background
                    ctx.fillStyle = this.colours.defaultFill;
                    if (this.editPosition.track === i) {
                        ctx.fillStyle = this.colours.currentTrackFill;
                    } else
                    if ( j == currentNote) {
                        ctx.fillStyle = this.colours.playingNoteFill;
                    } else if (selectedNote) {
                        ctx.fillStyle = this.colours.selectedFill;
                    } else {
                        // check if the current note in the current track is being edited
                        if (editedNote) {
                            ctx.fillStyle = this.colours.editNoteFill;
                        }
                    }
                    ctx.fillRect(rect.x + i * this.trackWidth, rect.y + offset * this.fonts.note.size, this.trackWidth, this.noteHeight);

                    note = track.getNote(j);
                    if ( note ) {
                        noteStr =
                            (note.noteName != null? note.noteName : '.') +
                                (note.isSharp ? '#' : note.noteName ? '-' : '.') +
                                (note.octave ? note.octave : note.noteName ? '0' : '.') +
                                ' ' +
                                (note.volume != null ? note.volume.toHex(2, true) : '..') +
                                ' ' +
                                (note.sampleID != null ? note.sampleID.toHex(2, true) : '..') +
                                ' ' +
                                '...';
                        if ( j == currentNote) {
                            ctx.fillStyle = this.colours.playingNoteText;
                        } else {
                            if ( editedNote ) {
                                ctx.fillStyle = this.colours.editNoteText;
                            } else if (selectedNote) {
                                ctx.fillStyle = this.colours.selectedText;
                            } else {
                                ctx.fillStyle = this.colours.defaultText;
                            }
                        }
                    } else {
                        if ( editedNote ) {
                            ctx.fillStyle = this.colours.editEmptyNoteText;
                        } else {
                            ctx.fillStyle = this.colours.emptyNoteText;
                        }
                        noteStr = '... .. .. ...';
                    }

                    // check if we need to render character by character (for the note currently being edited)
                    if ( editedNote ) {
                        let charOffset = 0, charWidth, oldFillStyle;
                        for ( let c = 0, strLen = noteStr.length; c < strLen; c++ ) {
                            charWidth = ctx.measureText(noteStr[c]).width;
                            if ( c == this.editPosition.position ) {
                                oldFillStyle = ctx.fillStyle;
                                ctx.fillStyle = this.colours.editPositionFill;
                                ctx.fillRect(rect.x + i * this.trackWidth + 7 + charOffset, rect.y + offset * this.fonts.note.size, charWidth, this.noteHeight);
                                ctx.fillStyle = oldFillStyle;
                            }
                            ctx.fillText(noteStr[c], rect.x + i * this.trackWidth + 7 + charOffset, rect.y + offset * this.fonts.note.size);
                            charOffset += charWidth;
                        }
                    } else {
                        ctx.fillText(noteStr, rect.x + i * this.trackWidth + 7, rect.y + offset * this.fonts.note.size);
                    }

                    if ( rect.y + offset * this.fonts.note.size + this.fonts.note.size*2 >= rect.y + rect.h) {
                        break;
                    }
                }
            }
            ctx.moveTo(rect.x + i * this.trackWidth, rect.y);
            ctx.lineTo(rect.x + i * this.trackWidth, rect.y + rect.h);

            ctx.stroke();
        }
    }

    _ensureNoteIsVisible(trackIndex, noteIndex) {
        let visibleNotes = Math.floor((this.rect.h / this.fonts.note.size)-1);

        if ( noteIndex < this.scrollOffset.y ) {
            this.scrollOffset.y = noteIndex;
        } else if ( noteIndex >= this.scrollOffset.y + visibleNotes ) {
            this.scrollOffset.y = noteIndex - visibleNotes;
        }
    }

    _navigateLeft(isSelecting) {
        if (!isSelecting) {
            if (this.editPosition.position > 0) {
                this.editPosition.position--;
                if (this.editPosition.position == 1 || this.editPosition.position == 3 || this.editPosition.position == 6 || this.editPosition.position == 9) {
                    this.editPosition.position--;
                }
            } else {
                if (this.editPosition.position == 0 && (this.editPosition.track > 0)) {
                    this.editPosition.track--;
                    this.editPosition.position = 12;
                }
            }
            this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
        } else {
            this.editPosition.track = this.editPosition.track > 0 ? this.editPosition.track - 1 : 0;
        }
    }

    _navigateRight(isSelecting) {
        if (!isSelecting) {
            if (this.editPosition.position < 12) {
                this.editPosition.position++;
                if (this.editPosition.position == 1 || this.editPosition.position == 3 || this.editPosition.position == 6 || this.editPosition.position == 9) {
                    this.editPosition.position++;
                }
            } else {
                if (this.pattern && (this.editPosition.track < this.pattern.getTrackCount() - 1)) {
                    this.editPosition.track++;
                    this.editPosition.position = 0;
                }
            }
            this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
        } else {
            this.editPosition.track = this.editPosition.track < 12 ? this.editPosition.track + 1 : 12;
        }
    }

    _navigateUp(isSelecting) {
        if (!isSelecting) {
            if (this.editPosition.note > 0) {
                this.editPosition.note--;
                this.editPosition.position = 0;
            }
        } else {
            this.editPosition.note = this.editPosition.note > 0 ? this.editPosition.note - 1 : 0;
        }
        this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
    }

    _navigateDown(isSelecting) {
        if (!isSelecting) {
            if (this.pattern && (this.editPosition.note < this.pattern.getNotesPerTrack() - 1)) {
                this.editPosition.note++;
                if (this.editPosition.position <= 2) this.editPosition.position = 0;
                if (this.editPosition.position >= 4 && this.editPosition.position <= 5) this.editPosition.position = 4;
            }
        } else {
            this.editPosition.note = this.editPosition.note < this.pattern.getNotesPerTrack() - 1 ? this.editPosition.note + 1 : this.pattern.getNotesPerTrack() - 1;
        }
        this._ensureNoteIsVisible(this.editPosition.track, this.editPosition.note);
    }

    _resetSelection() {
        console.log('Resetting selection');
        return {
            startTrack: -1,
            endTrack: -1,
            startNote: -1,
            endNote: -1
        };
    }

    _isSelectionEmpty() {
        return (
            this.selection.startNote === -1 &&
            this.selection.startTrack === -1 &&
            this.selection.endNote === -1 &&
            this.selection.endTrack === -1
        );
    }

    _addToSelection() {
        console.log('Adding note to selection');
        // if we have no selection at the moment, start it...
        if (this._isSelectionEmpty()) {
            this.selection.startNote = this.selection.endNote = this.editPosition.note;
            this.selection.startTrack = this.selection.endTrack = this.editPosition.track;
        } else {
            if (this.editPosition.note < this.selection.startNote) {
                this.selection.startNote = this.editPosition.note;
            } else if (this.editPosition.note > this.selection.endNote) {
                this.selection.endNote = this.editPosition.note;
            } else if (this.editPosition.note < this.selection.endNote) {
                this.selection.endNote = this.editPosition.note;
            } else if (this.editPosition.track < this.selection.startTrack) {
                this.selection.startTrack = this.editPosition.track;
            } else if (this.editPosition.track > this.selection.endTrack) {
                this.selection.endTrack = this.editPosition.track;
            } else if (this.editPosition.track < this.selection.endTrack) {
                this.selection.endTrack = this.editPosition.track;
            }
        }

        console.log(this.selection);
    }

    _transpose(bySemitones) {
        if (this._isSelectionEmpty()) {
            let track = this.pattern.getTrack(this.editPosition.track);
            for (let note of track.notes) {
                note ? note.increment(bySemitones) : null;
            }
        } else {

        }
    }

}